#hibernate #sql #dbms #java #spring-jpa #entity-manager  #jakarta-ee #jpa #transaction #entity-manager #nosql 

- Hibernate implements [Entity manager](programming/java/jakarta-ee/Entity%20manager.md) API on top of Database vendor drivers (Postgresql, Oracle, MySQL, ...)  and obviously ==creates an abstract layer.==

# Handle database vendor driver exception
- In some case, the mutable operations are only committed to the database at the end of the current transaction. As a result, `try catch` does not work. To resolve this, call `EntityManager.flush()`  to <mark style="background: #e4e62d;">force the application to commit</mark> the database layer.
- If the operation fails, there will be an ==exception== which is automatically ==thrown from the Database Driver layer== and that exception will ==propagate== to the Hibernate layer.
- Check out the ==Database vendor documentation== to know what has happened to your entity instance.
- For example:
	- `org.postgresql.util.PSQLException(<logging-message>, org.postgresql.util.PSQLState.<State>)` is encapsulated into `org.hibernate.exception.ConstraintViolationException` with its constraint name in database.

# Make entity instance persistent
- ![](Pasted%20image%2020240822175607.png)
- The field with `@Id` annotation is automatically generated by the Persistenc Context.
# Retrieve and update persistent entity instance
- ![800x500](Pasted%20image%2020240822181659.png)
- During the duration that the entity instance is being updated, Hibernate performs database necessary database locking.
# Retrieve a reference to entity instance
- If it is unnecessary to fully initialize the entity instance after being queried from database, call `EntityManager.getReference()` :
	- If the entity instance has ==already existed== in the persistence context, Hibernate will automatically return a reference to that object ==without hitting the database==.
	- Or Hibernate only ==initializes a shallow proxy== and defers the `SELECT` query statement. It lazily executes the query only if you access the entity instance.
## Advantages
- Slightly boost your performance because of I/O minization.
# Make entity instance transient
- ![800](Pasted%20image%2020240823095707.png)
- Only when the transaction ends or the `flush` method is explicitly called, the entity instance is certainly in transient state and will be garbage collected.
# Referesh the entity instance
- Performs a `SELECT`query from the database and overwrites all of the changes having been made to the current entity instance.
- Understood as "undo" operation.
# Replicate the entity instance (ongoing)
- Takes an detached entity instance loaded in one persistence context and makes them ==persistent in another persistent context==.
- Used to replicate data in multiple databases.
- `ReplicationMode`
# Hibernate caching in persistence context
- The [Hibernate dirty checking](Hibernate%20dirty%20checking.md) mechanism can lead to memory exhaustion because Hibernate allows caching entity instance within a Persistence Context.
- Use `queryHints` to disable caching mechanism
# Flush the persistence context
- Flushing means that you make a <mark style="background: #e4e62d;">commit</mark> from the transient$^{1}$ application instance stored on RAM to the <mark style="background: #e4e62d;">persistent record</mark> stored on disk. The result ends up either one of the two cases:
	- The entity instance is sucessfully stored on disk $\implies$ synchronized.
	- Hibernate failed to update the record and automatically rollback transaction $\implies$ nothing has changed.
# Working with detached entity instance
## Check equality
- Explicitly implements `equals` method and `hashCode` to check equality for detached entity instance.
## Merge entity instances
- ![](Pasted%20image%2020240823140026.png)
- Hibernate first checks whether there is a persistent entity instance having the same identifier as the detached entity instance's identifier within the current persistence context or not.
- If not, Hibernate therefore ==finds== an instance ==with that identifie==r from the database. If there exists, the `merge` ==overwrites== the detached entitty instance onto the loaded persistent entity instance.
- If the `merge` performs on a ==transient== entity instance without identifier field, Hibernate will ==instantiate== a fresh entity instance, ==copy== the value of the transient object onto it and ==make it persistent==.
## Remove a detached entity instance
- Merge the entity instance first, then remove it from the persistent context.
---
# Auxiliary
1. For me, for this context, the word "volatile" sounds more technical for the hardware.
---

# References
1. https://www.codejava.net/frameworks/spring-boot/spring-data-jpa-entitymanager-examples for implementation reference.
2. [Persistence lifecycle](Persistence%20lifecycle.md) 
3. 
